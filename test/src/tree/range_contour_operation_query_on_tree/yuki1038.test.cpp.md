---
data:
  _extendedDependsOn:
  - icon: ':heavy_check_mark:'
    path: library/tree/range_contour_operation_query_on_tree.hpp
    title: library/tree/range_contour_operation_query_on_tree.hpp
  _extendedRequiredBy: []
  _extendedVerifiedWith: []
  _isVerificationFailed: false
  _pathExtension: cpp
  _verificationStatusIcon: ':heavy_check_mark:'
  attributes:
    '*NOT_SPECIAL_COMMENTS*': ''
    PROBLEM: https://yukicoder.me/problems/no/1038
    links:
    - https://yukicoder.me/problems/no/1038
  bundledCode: "#line 1 \"test/src/tree/range_contour_operation_query_on_tree/yuki1038.test.cpp\"\
    \n#define PROBLEM \"https://yukicoder.me/problems/no/1038\"\n\n#include <iostream>\n\
    \n#line 1 \"library/tree/range_contour_operation_query_on_tree.hpp\"\n\n\n\n#include\
    \ <cstdint>\n#include <deque>\n#include <map>\n#include <queue>\n#include <tuple>\n\
    \nnamespace suisen {\n    template <typename T, typename F, T(*mapping)(F, T),\
    \ F(*composition)(F, F), F(*id)()>\n    struct RangeContourOperationQueryOnTree\
    \ {\n        RangeContourOperationQueryOnTree() {}\n        RangeContourOperationQueryOnTree(int\
    \ n, const T &fill_value) : RangeContourOperationQueryOnTree(std::vector<T>(n,\
    \ fill_value)) {}\n        RangeContourOperationQueryOnTree(const std::vector<T>\
    \ &dat) : _n(dat.size()), _g(_n), _par(_n, -1), _removed(_n, false), _pos(_n),\
    \ _idx(_n), _dist(_n), _sub(_n), _dat(dat) {}\n\n        struct CommutativeDualSegmentTree\
    \ {\n            CommutativeDualSegmentTree() {}\n            CommutativeDualSegmentTree(int\
    \ n) : _n(n), _laz(2 * _n, id()) {}\n            void apply(int l, int r, const\
    \ F& f) {\n                for (l += _n, r += _n; l < r; l >>= 1, r >>= 1) {\n\
    \                    if (l & 1) _laz[l] = composition(_laz[l], f), ++l;\n    \
    \                if (r & 1) --r, _laz[r] = composition(_laz[r], f);\n        \
    \        }\n            }\n            F get(int i) {\n                T res =\
    \ id();\n                for (i += _n; i; i >>= 1) res = composition(res, _laz[i]);\n\
    \                return res;\n            }\n        private:\n            int\
    \ _n;\n            std::vector<F> _laz;\n        };\n\n        using segtree_type\
    \ = CommutativeDualSegmentTree;\n\n        struct SubTree {\n            std::vector<int>\
    \ _sep;\n            segtree_type _seq;\n\n            SubTree() {}\n        \
    \    SubTree(\n                const std::vector<std::vector<int>>& g,\n     \
    \           const std::vector<int8_t>& removed,\n                const int root,\n\
    \                const bool is_right_child,\n                std::vector<std::vector<int8_t>>&\
    \ idx,\n                std::vector<std::vector<int>>& pos,\n                std::vector<std::vector<int>>&\
    \ dist\n            ) {\n                const int siz = dist.size();\n      \
    \          auto is_dummy_vertex = [&](int u) { return u >= siz; };\n         \
    \       _sep.push_back(0);\n                std::deque<std::tuple<int, int, int>>\
    \ dq{ { root, -1, 0 } };\n                int pre_dist = 0, cnt = 0;\n       \
    \         while (dq.size()) {\n                    const auto [u, pu, du] = dq.front();\n\
    \                    dq.pop_front();\n                    if (du == pre_dist +\
    \ 1) {\n                        _sep.push_back(cnt);\n                       \
    \ pre_dist = du;\n                    }\n                    bool b = is_dummy_vertex(u);\n\
    \                    if (not b) {\n                        pos[u].push_back(cnt++);\n\
    \                        idx[u].push_back(is_right_child);\n                 \
    \       dist[u].push_back(du);\n                    }\n                    for\
    \ (int v : g[u]) {\n                        if (v == pu or removed[v]) continue;\n\
    \                        if (b) {\n                            dq.emplace_front(v,\
    \ u, du);\n                        } else {\n                            dq.emplace_back(v,\
    \ u, du + 1);\n                        }\n                    }\n            \
    \    }\n                _sep.push_back(cnt);\n                _seq = segtree_type(cnt);\n\
    \            }\n\n            F get(int i) {\n                return _seq.get(i);\n\
    \            }\n            void apply(int dl, int dr, const F& val) {\n     \
    \           if (dl < 0) dl = 0;\n                if (dr >= int(_sep.size())) dr\
    \ = int(_sep.size()) - 1;\n                if (dl >= dr) return;\n           \
    \     int ql = _sep[dl], qr = _sep[dr];\n                _seq.apply(ql, qr, val);\n\
    \            }\n        };\n\n        void add_edge(int u, int v) {\n        \
    \    _g[u].push_back(v);\n            _g[v].push_back(u);\n        }\n\n     \
    \   void build() {\n            std::vector<int> sub(_n, 0);\n            std::vector<int>\
    \ ctr(_n, -1);\n            auto rec = [&](auto rec, int r, int siz) -> int {\n\
    \                int c = -1;\n                auto get_centroid = [&](auto get_centroid,\
    \ int u, int p) -> void {\n                    sub[u] = 1;\n                 \
    \   for (int v : _g[u]) {\n                        if (v == p or _removed[v])\
    \ continue;\n                        get_centroid(get_centroid, v, u);\n     \
    \                   if (v == c) {\n                            sub[u] = siz -\
    \ sub[c];\n                            break;\n                        }\n   \
    \                     sub[u] += sub[v];\n                    }\n             \
    \       if (c < 0 and sub[u] * 2 > siz) c = u;\n                };\n         \
    \       get_centroid(get_centroid, r, -1);\n\n                _removed[c] = true;\n\
    \                for (int v : _g[c]) {\n                    if (_removed[v]) continue;\n\
    \                    const int comp_size = sub[v];\n                    ctr[v]\
    \ = rec(rec, v, comp_size);\n                    sub[v] = comp_size;\n       \
    \         }\n\n                auto comp = [&](int i, int j) { return sub[i] >\
    \ sub[j]; };\n                std::priority_queue<int, std::vector<int>, decltype(comp)>\
    \ pq{ comp };\n\n                for (int v : _g[c]) {\n                    if\
    \ (_removed[v]) continue;\n                    pq.push(v);\n                }\n\
    \n                while (pq.size() >= 2) {\n                    int u = pq.top();\n\
    \                    pq.pop();\n                    int v = pq.top();\n      \
    \              pq.pop();\n                    if (pq.empty()) {\n            \
    \            _par[ctr[u]] = _par[ctr[v]] = c;\n                        _sub[c][0]\
    \ = SubTree{ _g, _removed, u, 0, _idx, _pos, _dist };\n                      \
    \  _sub[c][1] = SubTree{ _g, _removed, v, 1, _idx, _pos, _dist };\n          \
    \          } else {\n                        int new_node = sub.size();\n    \
    \                    sub.push_back(sub[u] + sub[v]);\n                       \
    \ ctr.push_back(new_node);\n                        _par.push_back(-1);\n    \
    \                    _par[ctr[u]] = _par[ctr[v]] = new_node;\n               \
    \         pq.push(new_node);\n                        _removed.push_back(false);\n\
    \                        _g.emplace_back();\n                        _g[new_node].push_back(u);\n\
    \                        _g[new_node].push_back(v);\n                        _sub.emplace_back();\n\
    \                        _sub[new_node][0] = SubTree{ _g, _removed, u, 0, _idx,\
    \ _pos, _dist };\n                        _sub[new_node][1] = SubTree{ _g, _removed,\
    \ v, 1, _idx, _pos, _dist };\n                    }\n                }\n     \
    \           if (pq.size()) {\n                    int u = pq.top();\n        \
    \            pq.pop();\n                    _par[ctr[u]] = c;\n              \
    \      _sub[c][0] = SubTree{ _g, _removed, u, 0, _idx, _pos, _dist };\n      \
    \          }\n                _removed[c] = false;\n                return c;\n\
    \            };\n            rec(rec, 0, _n);\n        }\n\n        T get(int\
    \ u) {\n            F res = id();\n            int h = _pos[u].size();\n     \
    \       for (int i = 0, v = _par[u]; i < h; ++i) {\n                res = composition(res,\
    \ _sub[std::exchange(v, _par[v])][_idx[u][i]].get(_pos[u][i]));\n            }\n\
    \            return mapping(res, _dat[u]);\n        }\n        void apply(int\
    \ u, int dl, int dr, const F& val) {\n            if (dl <= 0 and 0 < dr) _dat[u]\
    \ = mapping(val, _dat[u]);\n            _sub[u][0].apply(dl - 1, dr - 1, val);\n\
    \            _sub[u][1].apply(dl - 1, dr - 1, val);\n            int h = _pos[u].size();\n\
    \            for (int i = 0, v = _par[u]; i < h; ++i) {\n                int ql\
    \ = dl - _dist[u][i] - 2, qr = dr - _dist[u][i] - 2;\n                if (v <\
    \ _n and ql <= -1 and -1 < qr) _dat[v] = mapping(val, _dat[v]);\n            \
    \    _sub[std::exchange(v, _par[v])][_idx[u][i] ^ 1].apply(ql, qr, val);\n   \
    \         }\n        }\n\n    private:\n        int _n;\n        std::vector<std::vector<int>>\
    \ _g;\n        std::vector<int> _par;\n        std::vector<int8_t> _removed;\n\
    \        std::vector<std::vector<int>> _pos;\n        std::vector<std::vector<int8_t>>\
    \ _idx;\n        std::vector<std::vector<int>> _dist;\n        std::vector<std::array<SubTree,\
    \ 2>> _sub;\n        std::vector<T> _dat;\n    };\n} // namespace suisen\n\n\n\
    \n#line 6 \"test/src/tree/range_contour_operation_query_on_tree/yuki1038.test.cpp\"\
    \n\nlong long mapping(long long f, long long x) {\n    return f + x;\n}\nlong\
    \ long composition(long long x, long long y) {\n    return x + y;\n}\nlong long\
    \ id() {\n    return 0;\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n\
    \    std::cin.tie(nullptr);\n\n    int n, q;\n    std::cin >> n >> q;\n\n    suisen::RangeContourOperationQueryOnTree<long\
    \ long, long long, mapping, composition, id> g(n, 0LL);\n    for (int i = 0; i\
    \ < n - 1; ++i) {\n        int u, v;\n        std::cin >> u >> v;\n        --u,\
    \ --v;\n        g.add_edge(u, v);\n    }\n    g.build();\n\n    for (int i = 0;\
    \ i < q; ++i) {\n        int x, y, z;\n        std::cin >> x >> y >> z;\n    \
    \    --x, ++y;\n        std::cout << g.get(x) << '\\n';\n        g.apply(x, 0,\
    \ y, z);\n    }\n\n    return 0;\n}\n"
  code: "#define PROBLEM \"https://yukicoder.me/problems/no/1038\"\n\n#include <iostream>\n\
    \n#include \"library/tree/range_contour_operation_query_on_tree.hpp\"\n\nlong\
    \ long mapping(long long f, long long x) {\n    return f + x;\n}\nlong long composition(long\
    \ long x, long long y) {\n    return x + y;\n}\nlong long id() {\n    return 0;\n\
    }\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n\
    \n    int n, q;\n    std::cin >> n >> q;\n\n    suisen::RangeContourOperationQueryOnTree<long\
    \ long, long long, mapping, composition, id> g(n, 0LL);\n    for (int i = 0; i\
    \ < n - 1; ++i) {\n        int u, v;\n        std::cin >> u >> v;\n        --u,\
    \ --v;\n        g.add_edge(u, v);\n    }\n    g.build();\n\n    for (int i = 0;\
    \ i < q; ++i) {\n        int x, y, z;\n        std::cin >> x >> y >> z;\n    \
    \    --x, ++y;\n        std::cout << g.get(x) << '\\n';\n        g.apply(x, 0,\
    \ y, z);\n    }\n\n    return 0;\n}"
  dependsOn:
  - library/tree/range_contour_operation_query_on_tree.hpp
  isVerificationFile: true
  path: test/src/tree/range_contour_operation_query_on_tree/yuki1038.test.cpp
  requiredBy: []
  timestamp: '2022-03-31 22:21:43+09:00'
  verificationStatus: TEST_ACCEPTED
  verifiedWith: []
documentation_of: test/src/tree/range_contour_operation_query_on_tree/yuki1038.test.cpp
layout: document
redirect_from:
- /verify/test/src/tree/range_contour_operation_query_on_tree/yuki1038.test.cpp
- /verify/test/src/tree/range_contour_operation_query_on_tree/yuki1038.test.cpp.html
title: test/src/tree/range_contour_operation_query_on_tree/yuki1038.test.cpp
---
